const AWS = require("aws-sdk");
const dynamo = new AWS.DynamoDB.DocumentClient({ region: "us-east-1" });
const s3 = new AWS.S3();

const rootS3Path = "https://charity-registration-documents.s3.amazonaws.com";

exports.handler = async (event, context) => {
  const requestBody = JSON.parse(event.body);

  // event.queryStringParameters contains 'uuid' which represents User PK
  return await updateCharityData(requestBody, event.queryStringParameters);
};

// Update Charity Data
const updateCharityData = async (body, event) => {
  let data;

  try {
    if (Object.keys(body).length === 0) {
      return buildResponse("204", { message: "No new content was passed." });

      // We don't check for body.FinancialStatements or body.AuditedFinancialReports because they're not required
    } else if (body.ProofOfIdentity || body.ProofOfRegistration) {
      const { Website, UN_SDG, ...documentation } = body;
      const documentationUrlsObject = await uploadDocumentation(
        documentation,
        event.uuid
      );
      const params = buildUpdateQueryDocumentation(
        documentationUrlsObject,
        Website,
        UN_SDG,
        event.uuid
      );

      data = await dynamo.update(params).promise();
    } else if (body.Email) {
      const expression1 = buildUpdateQueryContactPerson(body, event.uuid);
      const expression2 = buildUpdateQueryRegistration(
        body.Email,
        body.CharityName,
        event.uuid
      );
      const params = {
        TransactItems: [
          { Update: { ...expression1 } },
          { Update: { ...expression2 } },
        ],
      };
      data = await dynamo.transactWrite(params).promise();
    } else {
      const params = buildUpdateQueryContactPerson(body, event.uuid);
      data = await dynamo.update(params).promise();
    }

    if (data) {
      return buildResponse("201", { message: "Updated successfully!" });
    }
  } catch (err) {
    return buildResponse("400", err);
  }
};

// Handles the response sent back to the client
const buildResponse = (statusCode, body) => {
  return {
    statusCode: statusCode,
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  };
};

// Preps the template for updating ContactPerson items
const buildUpdateQueryContactPerson = (field, uuid) => {
  let query = {
    TableName: "TEST_CharityRegistration",
    Key: {
      PK: uuid,
      SK: "ContactPerson",
    },
    UpdateExpression: "set",
    ExpressionAttributeNames: {},
    ExpressionAttributeValues: {},
  };

  Object.entries(field).forEach(([key, item]) => {
    query.UpdateExpression += ` #${key} = :${key},`;
    query.ExpressionAttributeNames[`#${key}`] = key;
    query.ExpressionAttributeValues[`:${key}`] = item;
  });

  query.UpdateExpression = query.UpdateExpression.slice(0, -1); //Removes last comma because it will cause an error
  return query;
};

// Preps the template for updating Registration items
const buildUpdateQueryRegistration = (email, charityName, uuid) => {
  let query = {
    TableName: "TEST_CharityRegistration",
    Key: {
      PK: uuid,
      SK: "Registration",
    },
    UpdateExpression:
      "set #CharityName_ContactEmail = :CharityName_ContactEmail",
    ExpressionAttributeNames: {
      "#CharityName_ContactEmail": "CharityName_ContactEmail",
    },
    ExpressionAttributeValues: {
      ":CharityName_ContactEmail": `${charityName.toUpperCase()}_${email}`,
    },
  };

  return query;
};

// Preps the template for updating Registration items, Documentation & DocumentVerified
const buildUpdateQueryDocumentation = (
  documentationUrlsObject,
  Website,
  UN_SDG,
  uuid
) => {
  let query = {
    TableName: "TEST_CharityRegistration",
    Key: {
      PK: uuid,
      SK: "Registration",
    },
    UpdateExpression: "set",
    ExpressionAttributeNames: {},
    ExpressionAttributeValues: {},
  };

  Object.entries(documentationUrlsObject).forEach(([key, item]) => {
    query.UpdateExpression += ` #${key} = :${key}, #${key}Verified = :${key}Verified,`;
    query.ExpressionAttributeNames[`#${key}`] = key;
    query.ExpressionAttributeValues[`:${key}`] = item;
    query.ExpressionAttributeNames[`#${key}Verified`] = key + "Verified";
    query.ExpressionAttributeValues[`:${key}Verified`] = false;
  });

  const websiteKey = "Website";
  query.UpdateExpression += ` #${websiteKey} = :${websiteKey},`;
  query.ExpressionAttributeNames[`#${websiteKey}`] = websiteKey;
  query.ExpressionAttributeValues[`:${websiteKey}`] = Website;

  const unSdgKey = "UN_SDG";
  query.UpdateExpression += ` #${unSdgKey} = :${unSdgKey}`;
  query.ExpressionAttributeNames[`#${unSdgKey}`] = unSdgKey;
  query.ExpressionAttributeValues[`:${unSdgKey}`] = UN_SDG;

  return query;
};

/**
 * Handles S3 Documentation uploading. In case of multiple uploads at once, if one fails, the whole process fails.
 * Returns an object containing S3 URLs.
 *
 * @param {Object}  documentation Documentation object in following format:
 * {
 *   ProofOfIdentity: { name: string; dataUrl: string };
 *   ProofOfRegistration: { name: string; dataUrl: string };
 *   FinancialStatements: { name: string; dataUrl: string }[];
 *   AuditedFinancialReports: { name: string; dataUrl: string }[];
 * }
 * @param {Integer} uuid User PK.
 * @returns {Object} Object containing URLs to uploaded documents.
 */
const uploadDocumentation = async (documentation, uuid) => {
  let documentationUrlsObject = {};
  let errors = [];

  try {
    await Promise.all(
      Object.entries(documentation).map(async ([key, value]) => {
        // if it's not an array, turn it into one
        const documents = !value?.length ? [value] : value;

        const results = await uploadDocuments(key, documents, uuid);

        const uploadErrors = results.filter((x) => !!x.error)?.error;
        if (!!uploadErrors?.length) {
          errors = errors.concat(uploadErrors);
          return;
        }

        documentationUrlsObject[key] = results
          .filter((res) => !!res.filePath)
          .map((res) => `${rootS3Path}/${res.filePath}`);
      })
    );

    const unsupportedMediaError = errors?.find((err) =>
      err.toLowerCase().includes("unsupported media type")
    );
    if (!!unsupportedMediaError) {
      return buildResponse("415", unsupportedMediaError);
    }
    if (!!errors?.length) {
      return buildResponse("400", errors.join(" \n"));
    }

    return documentationUrlsObject;
  } catch (err) {
    return buildResponse("400", err);
  }
};

const DOCUMENT_FOLDER_MAP = {
  ProofOfIdentity: "proof-of-identity",
  ProofOfRegistration: "proof-of-registration",
  FinancialStatements: "financial-statements",
  AuditedFinancialReports: "audited-financial-reports",
};

const uploadDocuments = async (documentType, documents, uuid) =>
  await Promise.all(
    documents.map(async (doc) => {
      try {
        const fileType = doc.dataUrl.split(";");
        const rawBase64 = doc.dataUrl.split(",")[1];
        const decodedFile = Buffer.from(rawBase64, "base64"); // Decode base64 to binary

        const { fileExtension, contentType, error } = getFileMetadata(fileType);

        if (!!error) {
          return { error };
        }

        const filePath = `${DOCUMENT_FOLDER_MAP[documentType]}/${uuid}${fileExtension}`;
        const s3Params = {
          Body: decodedFile,
          Bucket: "charity-registration-documents",
          Key: filePath,
          ContentType: contentType,
        };
        await s3.upload(s3Params).promise();

        return { filePath };
      } catch (err) {
        return { err };
      }
    })
  );

const getFileMetadata = (fileType) => {
  switch (true) {
    case fileType[0] === "data:image/jpeg" ||
      fileType[0] === "data:@file/jpeg" ||
      fileType[0] === "data:/jpeg":
      return {
        contentType: "image/jpeg",
        fileExtension: ".jpeg",
      };
    case fileType[0] === "data:image/png" ||
      fileType[0] === "data:@file/png" ||
      fileType[0] === "data:/png":
      return {
        contentType: "image/png",
        fileExtension: ".png",
      };
    case fileType[0] === "data:application/pdf" ||
      fileType[0] === "data:@file/pdf" ||
      fileType[0] === "data:/pdf":
      return {
        contentType: "application/pdf",
        fileExtension: ".pdf",
      };
    default:
      return { error: `Unsupported Media Type ${fileType}` };
  }
};
